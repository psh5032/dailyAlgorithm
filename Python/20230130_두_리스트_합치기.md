> 인프런 - 김태원 강사님의 '파이썬 알고리즘 문제풀이 입문' 문제 풀이

- 복습 필요

<br>

- 단순히 두 리스트를 합쳐서 정렬된 하나의 리스트를 만들기 위해서는 파이썬의 경우 연산자를 이용해 두 리스트를 더하고 sort()로 정렬하면 되지만 sort()는 퀵정렬을 사용하므로 시간 복잡도가 NlogN이다.
- 하지만 아래의 방법은 시간 복잡도가 N이 된다.
- 이는 데이터가 적을 땐 차이가 안나지만 데이터가 많아지면 큰 차이가 발생한다. 

# 나의 코드
- 강사님 코드와 가장 큰 차이점은 while문의 작성 방식이다. 
- 나는 while문의 조건을 True로 적고 특정 조건에서 break를 하게 했지만 강사님은 while문 조건을 통해 바로 break되어 반복문을 빠져나올 수 있도록 한번에 작성하여 코드가 더 간결해졌다.
```python
import sys
sys.stdin=open("input.txt","rt") 

n=int(input())
a=list(map(int, input().split()))
m=int(input())
b=list(map(int, input().split()))
c=[]
p1, p2=0, 0

while True:
    if a[p1]<b[p2]:
        c.append(a[p1])
        p1+=1
    else:
        c.append(b[p2])
        p2+=1
    if p1==n or p2==m:
        break

if p1==n:
    c=c+b[p2:]
else:
    c=c+a[p1:]

for x in c:
    print(x, end=' ')
```

# 강사님의 코드
```python
n=int(input())
a=list(map(int, input().split()))
m=int(input())
b=list(map(int, input().split()))
p1=p2=0
c=[]
while p1<n and p2<m:
    if a[p1]<=b[p2]:
        c.append(a[p1])
        p1+=1
    else:
        c.append(b[p2])
        p2+=1

if p1<n:
    c=c+a[p1:]
if p2<m:
    c=c+b[p2:]

for x in c:
    print(x, end=' ')
```